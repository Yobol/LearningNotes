# 内部排序算法

## 插入排序

简单直观。每次将一个待排序的的元素，按其关键字大小插入到前面已经排好序的子序列中，直到全部元素插入完成。

### 直接插入排序

**Description**

实现插入排序。

**Input**

输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。

**Output**

输出排序的数组，用空格隔开，末尾不要空格。

**Sample Input**

```
13 24 3 56 34 ‘3’ 78 12 29 49 84 51 9 100
```

**Sample Output**

```
3 ‘3’ 9 12 24 29 34 49 51 56 78 84 100
```

#### Solution 1

##### 基本思想

设初始有序序列为V(0)，每次将元素V(i)(i∈[1,n-1])依次插入到已排好序的有序子序列中。

- 遍历有序序列V(0,...,i-1)，查找出V(i)在V(0,...,i-1)中的插入位置k；
- 将V(k,...,i-1)中的所有元素向后移动一个位置；
---

在具体实现中，我们可以将以上两个步骤分为两个阶段（先找出位置k，再后移k之后且不包括k的元素），也可以在查找位置k的过程中，完成元素后移操作（如实现示例）。

---
- 将Vi复制到Vk；

将上述步骤重复执行n-1次就能得到一个有序序列。

排序过程示例：

| 初始序列                | 8    | 3    | 2    | 5    | 9    | 1    | 6    |
| ----------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 只包含元素8的初始子序列 | 8    |      |      |      |      |      |      |
| 插入元素3后的有序子序列 | 3    | 8    |      |      |      |      |      |
| 插入元素2后的有序子序列 | 2    | 3    | 8    |      |      |      |      |
| 插入元素5后的有序子序列 | 2    | 3    | 5    | 8    |      |      |      |
| 插入元素9后的有序子序列 | 2    | 3    | 5    | 8    | 9    |      |      |
| 插入元素1后的有序子序列 | 1    | 2    | 3    | 5    | 8    | 9    |      |
| 插入元素6后的有序子序列 | 1    | 2    | 3    | 5    | 6    | 8    | 9    |

包含7个元素的待排序列，只需要重复执行上述步骤6次即可得到有序序列。

##### Python3

```python
def insertion_sort(arr, size):
    for i in range(1, size):
        tmp = arr[i]

        # 从arr[i]向前开始比较，只要arr[i] < arr[j-1]就不断地将arr[j-1]后移
        j = i
        while j >= 1 and tmp < arr[j - 1]:
            arr[j] = arr[j - 1]
            j -= 1
        arr[j] = tmp
```

##### Java

```Java
/**
 * 每次都将一个待排序的元素，按其关键字大小插入到前面已经排好序的子序列中，直到全部元素插入完成
 * @param nums
 */
public void insertionSort(int[] nums) {
    int j;

    for (int i = 1; i < nums.length; i++) {
        int cur = nums[i];

        for (j = i; j >= 1 && cur < nums[j - 1]; j--) {
            nums[j] = nums[j - 1];
        }
        nums[j] = cur;
    }
}
```

##### 算法分析

###### 空间复杂度

仅使用了常数个辅助存储单元，因此空间复杂度为O(1)。

###### 时间复杂度

在排序过程中，向有序子序列中插入元素的操作进行了n-1趟，而每趟操作都分为比较关键字和移动元素，且这两种操作的次数都取决于待排序表的初始状态。

| ...         | 最好情况：有序 | 最坏情况：逆序                           | 平均   |
| ----------- | -------------- | ---------------------------------------- | ------ |
| 比较次数KCN | n - 1          | Σ(n-i), i∈[1,n-1]                        | O(n^2) |
| 移动次数RMN | 0              | Σ(n-i), i∈[2+1,2+n-1] 一次交换，三次移动 | O(n^2) |
| 复杂度      | O(n)           | 0(n^2)                                   | O(n^2) |

###### 稳定性

由于每次插入元素时总是从后往前先比较再移动（从arr[i]向前开始比较，只要arr[i] < arr[j-1]就不断地将arr[j-1]后移），所以不会出现相同元素相同位置发生变化的情况。

###### 适用性

待排序列基本有序或数量不大。

### 折半插入排序/二分插入排序

#### Solution 1

##### 基本思想

与直接插入排序边比较边移动元素的做法不同，二分插入排序将比较和移动操作分离开来：

1. 先用二分查找法找出元素的插入位置k；
2. 再统一将待插入位置及之后的所有元素后移一个位置；
3. 将V(i)赋值给V(k)。

同样地，将上述步骤重复执行n-1次就能得到一个有序序列。

排序过程示例：

| 初始序列                | 8    | 3    | 2    | 5    | 9    | 1    | 6    |
| ----------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 只包含元素8的初始子序列 | 8    |      |      |      |      |      |      |
| 插入元素3后的有序子序列 | 3    | 8    |      |      |      |      |      |
| 插入元素2后的有序子序列 | 2    | 3    | 8    |      |      |      |      |
| 插入元素5后的有序子序列 | 2    | 3    | 5    | 8    |      |      |      |
| 插入元素9后的有序子序列 | 2    | 3    | 5    | 8    | 9    |      |      |
| 插入元素1后的有序子序列 | 1    | 2    | 3    | 5    | 8    | 9    |      |
| 插入元素6后的有序子序列 | 1    | 2    | 3    | 5    | 6    | 8    | 9    |

包含7个元素的待排序列，只需要重复执行上述步骤6次即可得到有序序列。

##### Python3

##### Java

```Java
/**
 * Searches a range of
 * the specified array of ints for the specified value using the
 * binary search algorithm.
 * The range must be sorted (as
 * by the {@link #sort(int[], int, int)} method)
 * prior to making this call.  If it
 * is not sorted, the results are undefined.  If the range contains
 * multiple elements with the specified value, there is no guarantee which
 * one will be found.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 *          searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array
 *         within the specified range;
 *         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
 *         <i>insertion point</i> is defined as the point at which the
 *         key would be inserted into the array: the index of the first
 *         element in the range greater than the key,
 *         or <tt>toIndex</tt> if all
 *         elements in the range are less than the specified key.  Note
 *         that this guarantees that the return value will be &gt;= 0 if
 *         and only if the key is found.
 * @throws IllegalArgumentException
 *         if {@code fromIndex > toIndex}
 * @throws ArrayIndexOutOfBoundsException
 *         if {@code fromIndex < 0 or toIndex > a.length}
 * @since 1.6
 */
public static int binarySearch(int[] a, int fromIndex, int toIndex,
                               int key) {
    rangeCheck(a.length, fromIndex, toIndex);
    return binarySearch0(a, fromIndex, toIndex, key);
}

/**
 * Checks that {@code fromIndex} and {@code toIndex} are in
 * the range and throws an exception if they aren't.
 */
private static void rangeCheck(int arrayLength, int fromIndex, int toIndex) {
    if (fromIndex > toIndex) {
        throw new IllegalArgumentException(
            "fromIndex(" + fromIndex + ") > toIndex(" + toIndex + ")");
    }
    if (fromIndex < 0) {
        throw new ArrayIndexOutOfBoundsException(fromIndex);
    }
    if (toIndex > arrayLength) {
        throw new ArrayIndexOutOfBoundsException(toIndex);
    }
}

// Like public version, but without range checks.
private static int binarySearch(int[] a, int fromIndex, int toIndex, int key) {
    int low = fromIndex;
    int high = toIndex - 1;

    while (low <= high) {
        int mid = (low + high) >>> 1;
        int midVal = a[mid];

        if (midVal < key)
            low = mid + 1;
        else if (midVal > key)
            high = mid - 1;
        else
            return mid; // key found
    }
    return -(low + 1);  // key not found.
}

/**
 *
 * 1. 先用二分查找法（调用java util.Arrays.binarySearch()方法，上面给出了源码）找出元素的插入位置k；
 * 2. 再统一将待插入位置及之后的所有元素后移一个位置；
 * 3. 将V(i)赋值给V(k)。
 */
public void binarySearchSort(int[] a) {

    for (int i = 1; i < a.length; i++) {
        int cur = a[i];
        
        int k = Arrays.binarySearch(a, 0, i, cur);
        // 如果要查找的key不存在，则返回-(k + 1) < 0，那么k = -k - 1
        if (k < 0) {
            k = -k - 1;
        }
        for (int j = i; j > k; j--) {
            a[j] = a[j - 1];
        }
        a[k] = cur;
    }
}
```

##### 算法分析

###### 空间复杂度

仅使用了常数个辅助存储单元，因此空间复杂度为O(1)。

###### 时间复杂度

比较次数与初始序列无关，而仅依赖于元素个数n，与直接插入排序相比，仅仅是减少了比较次数，约为O(nlogn)；

而移动次数没有改变，依赖于待排序列的初始状态，仍为O(n ^ 2)。

###### 稳定性

稳定。

###### 适用性

待排序列基本有序或数量不大。


