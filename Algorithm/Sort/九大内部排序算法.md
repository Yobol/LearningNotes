# 内部排序算法

## 插入排序

简单直观。每次将一个待排序的的元素，按其关键字大小插入到前面已经排好序的子序列中，直到全部元素插入完成。

### 直接插入排序

**Description**

实现插入排序。

**Input**

输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。

**Output**

输出排序的数组，用空格隔开，末尾不要空格。

**Sample Input**

```
13 24 3 56 34 ‘3’ 78 12 29 49 84 51 9 100
```

**Sample Output**

```
3 ‘3’ 9 12 24 29 34 49 51 56 78 84 100
```

#### Solution 1

##### 基本思想

设初始有序序列为V(0)，每次将元素V(i)(i∈[1,n-1])依次插入到已排好序的有序子序列中。

- 遍历有序序列V(0,...,i-1)，查找出V(i)在V(0,...,i-1)中的插入位置k；
- 将V(k,...,i-1)中的所有元素向后移动一个位置；
---

在具体实现中，我们可以将以上两个步骤分为两个阶段（先找出位置k，再后移k之后且不包括k的元素），也可以在查找位置k的过程中，完成元素后移操作（如实现示例）。

---
- 将Vi复制到Vk；

将上述步骤重复执行n-1次就能得到一个有序序列。

排序过程示例：

| 初始序列                | 8    | 3    | 2    | 5    | 9    | 1    | 6    |
| ----------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 只包含元素8的初始子序列 | 8    |      |      |      |      |      |      |
| 插入元素3后的有序子序列 | 3    | 8    |      |      |      |      |      |
| 插入元素2后的有序子序列 | 2    | 3    | 8    |      |      |      |      |
| 插入元素5后的有序子序列 | 2    | 3    | 5    | 8    |      |      |      |
| 插入元素9后的有序子序列 | 2    | 3    | 5    | 8    | 9    |      |      |
| 插入元素1后的有序子序列 | 1    | 2    | 3    | 5    | 8    | 9    |      |
| 插入元素6后的有序子序列 | 1    | 2    | 3    | 5    | 6    | 8    | 9    |

包含7个元素的待排序列，只需要重复执行上述步骤6次即可得到有序序列。

##### Python3

```python
def insertion_sort(arr, size):
    for i in range(1, size):
        tmp = arr[i]

        # 从arr[i]向前开始比较，只要arr[i] < arr[j-1]就不断地将arr[j-1]后移
        j = i
        while j >= 1 and tmp < arr[j - 1]:
            arr[j] = arr[j - 1]
            j -= 1
        arr[j] = tmp
```

##### Java

```Java
/**
 * 每次都将一个待排序的元素，按其关键字大小插入到前面已经排好序的子序列中，直到全部元素插入完成
 * @param nums
 */
public void insertionSort(int[] nums) {
    int j;

    for (int i = 1; i < nums.length; i++) {
        int cur = nums[i];

        for (j = i; j >= 1 && cur < nums[j - 1]; j--) {
            nums[j] = nums[j - 1];
        }
        nums[j] = cur;
    }
}
```

##### 算法分析

###### 空间复杂度

仅使用了常数个辅助存储单元，因此空间复杂度为O(1)。

###### 时间复杂度

在排序过程中，向有序子序列中插入元素的操作进行了n-1趟，而每趟操作都分为比较关键字和移动元素，且这两种操作的次数都取决于待排序表的初始状态。

| ...         | 最好情况：有序 | 最坏情况：逆序                           | 平均   |
| ----------- | -------------- | ---------------------------------------- | ------ |
| 比较次数KCN | n - 1          | Σ(n-i), i∈[1,n-1]                        | O(n^2) |
| 移动次数RMN | 0              | Σ(n-i), i∈[2+1,2+n-1] 一次交换，三次移动 | O(n^2) |
| 复杂度      | O(n)           | 0(n^2)                                   | O(n^2) |

###### 稳定性

由于每次插入元素时总是从后往前先比较再移动（从arr[i]向前开始比较，只要arr[i] < arr[j-1]就不断地将arr[j-1]后移），所以不会出现相同元素相同位置发生变化的情况。

###### 适用性

待排序列基本有序或数量不大。

### 折半插入排序/二分插入排序

#### Solution 1

##### 基本思想

与直接插入排序边比较边移动元素的做法不同，二分插入排序将比较和移动操作分离开来：

1. 先用二分查找法找出元素的插入位置k；
2. 再统一将待插入位置及之后的所有元素后移一个位置；
3. 将V(i)赋值给V(k)。

同样地，将上述步骤重复执行n-1次就能得到一个有序序列。

排序过程示例：

| 初始序列                | 8    | 3    | 2    | 5    | 9    | 1    | 6    |
| ----------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 只包含元素8的初始子序列 | 8    |      |      |      |      |      |      |
| 插入元素3后的有序子序列 | 3    | 8    |      |      |      |      |      |
| 插入元素2后的有序子序列 | 2    | 3    | 8    |      |      |      |      |
| 插入元素5后的有序子序列 | 2    | 3    | 5    | 8    |      |      |      |
| 插入元素9后的有序子序列 | 2    | 3    | 5    | 8    | 9    |      |      |
| 插入元素1后的有序子序列 | 1    | 2    | 3    | 5    | 8    | 9    |      |
| 插入元素6后的有序子序列 | 1    | 2    | 3    | 5    | 6    | 8    | 9    |

包含7个元素的待排序列，只需要重复执行上述步骤6次即可得到有序序列。

##### Python3

##### Java

```Java
/**
 * Searches a range of
 * the specified array of ints for the specified value using the
 * binary search algorithm.
 * The range must be sorted (as
 * by the {@link #sort(int[], int, int)} method)
 * prior to making this call.  If it
 * is not sorted, the results are undefined.  If the range contains
 * multiple elements with the specified value, there is no guarantee which
 * one will be found.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 *          searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array
 *         within the specified range;
 *         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
 *         <i>insertion point</i> is defined as the point at which the
 *         key would be inserted into the array: the index of the first
 *         element in the range greater than the key,
 *         or <tt>toIndex</tt> if all
 *         elements in the range are less than the specified key.  Note
 *         that this guarantees that the return value will be &gt;= 0 if
 *         and only if the key is found.
 * @throws IllegalArgumentException
 *         if {@code fromIndex > toIndex}
 * @throws ArrayIndexOutOfBoundsException
 *         if {@code fromIndex < 0 or toIndex > a.length}
 * @since 1.6
 */
public static int binarySearch(int[] a, int fromIndex, int toIndex,
                               int key) {
    rangeCheck(a.length, fromIndex, toIndex);
    return binarySearch0(a, fromIndex, toIndex, key);
}

/**
 * Checks that {@code fromIndex} and {@code toIndex} are in
 * the range and throws an exception if they aren't.
 */
private static void rangeCheck(int arrayLength, int fromIndex, int toIndex) {
    if (fromIndex > toIndex) {
        throw new IllegalArgumentException(
            "fromIndex(" + fromIndex + ") > toIndex(" + toIndex + ")");
    }
    if (fromIndex < 0) {
        throw new ArrayIndexOutOfBoundsException(fromIndex);
    }
    if (toIndex > arrayLength) {
        throw new ArrayIndexOutOfBoundsException(toIndex);
    }
}

// Like public version, but without range checks.
private static int binarySearch(int[] a, int fromIndex, int toIndex, int key) {
    int low = fromIndex;
    int high = toIndex - 1;

    while (low <= high) {
        int mid = (low + high) >>> 1;
        int midVal = a[mid];

        if (midVal < key)
            low = mid + 1;
        else if (midVal > key)
            high = mid - 1;
        else
            return mid; // key found
    }
    return -(low + 1);  // key not found.
}

/**
 *
 * 1. 先用二分查找法（调用java util.Arrays.binarySearch()方法，上面给出了源码）找出元素的插入位置k；
 * 2. 再统一将待插入位置及之后的所有元素后移一个位置；
 * 3. 将V(i)赋值给V(k)。
 */
public void binarySearchSort(int[] a) {

    for (int i = 1; i < a.length; i++) {
        int cur = a[i];
        
        int k = Arrays.binarySearch(a, 0, i, cur);
        // 如果要查找的key不存在，则返回-(k + 1) < 0，那么k = -k - 1
        if (k < 0) {
            k = -k - 1;
        }
        for (int j = i; j > k; j--) {
            a[j] = a[j - 1];
        }
        a[k] = cur;
    }
}
```

##### 算法分析

###### 空间复杂度

仅使用了常数个辅助存储单元，因此空间复杂度为O(1)。

###### 时间复杂度

比较次数与初始序列无关，而仅依赖于元素个数n，与直接插入排序相比，仅仅是减少了比较次数，约为O(nlogn)；

而移动次数没有改变，依赖于待排序列的初始状态，仍为O(n ^ 2)。

###### 稳定性

稳定。

###### 适用性

待排序列基本有序或数量不大。

### 希尔排序

又称缩小增量排序（Diminishing-Increment Sort）。

**Description**

实现Shell排序，对给定的无序数组，按照给定的间隔变化（间隔大小即同组数字index的差），打印排序结果，注意不一定是最终排序结果！

**Input**

输入第一行表示测试用例个数，后面为测试用例，每一个用例有两行，第一行为给定数组，第二行为指定间隔，每一个间隔用空格隔开。

**Output**

输出的每一行为一个用例对应的指定排序结果。

**Sample Input**

```
1
49 38 65 97 76 13 27 49 55 4
5 3
```

**Sample Output**

```
13 4 49 38 27 49 55 65 97 76
```

#### Solution 1

##### 基本思想

将待排序列在逻辑上分割成若干个形如`V(i,i+d,...,i+kd)(i∈[0,d))`的子序列，分别进行直接插入排序，不断缩小d的值，即逐渐扩大子序列的长度，直到所有子序列”合并“为一个序列时（此时，整个序列中的元素”基本有序“），再对整个序列进行一次直接插入排序。

`注：当待排序列中的元素基本有序时，效率最高的排序算法是直接插入排序。`

给定一个递减的增量序列，(d1,d2,...,dt = 1)

1. 从增量序列中取第一个增量d1（d1<n)，然后按增量d1将序列分成d1个组，所有下标模d1为`i(i∈[0,d)`的元素放在同一组中（每个组至多有`⌈n/d1⌉`个元素）,对各子序列分别进行直接插入排序；
2. 接着从增量序列中取第二个增量d2（d2<d1），重复上述过程，直到所取到的增量dt = 1，即所有元素在同一序列中；
3. 对整个序列进行一次直接插入排序（这个时候序列已经具有较好的局部有序性，故可以很快得到最终结果）；

`注：增量序列的性能与增量序列有关。Shell排序算法的作者提出的方法是d1=⌊n/2⌋,di+1=⌊di/2⌋，并且最后一个增量等于1。`

排序过程示例（增量序列为(3,1)）：

| 初始序列              | 8    | 3    | 2    | 5    | 9    | 1    | 6    |
| --------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| n=7，增量d1为⌊7/2⌋=3  | 5    | 3    | 1    | 6    | 9    | 2    | 8    |
| d1=3，增量d2为⌊3/2⌋=1 | 1    | 2    | 3    | 5    | 6    | 8    | 9    |

包含7个元素的待排序列，只需要重复执行上述步骤6次即可得到有序序列。

##### Python3

```Python
def shell_sort(nums):
    gap = len(nums) / 2
    while gap >= 1:
        for i in range(gap, len(nums), 1):
            cur = nums[i]

            j = i
            while j >= gap and cur < nums[j - gap]:
                nums[j] = nums[j - gap]
                j -= gap
            nums[j] = cur
        gap /= 2
```

##### Java

```Java
/**
 * 将待排序列在逻辑上分割成若干个形如V(i,i+d,...,i+kd)(i∈[0,d))的子序列，分别进行直接插入排序
 * 不断缩小d的值，即逐渐扩大子序列的长度，直到所有子序列”合并“为一个序列时
 * 此时，整个序列中的元素”基本有序“，再对整个序列进行一次直接插入排序。
 */
private void shellSort(int[] nums) {
    for (int gap = nums.length / 2; gap >= 1; gap /= 2) {
        for (int i = gap; i < nums.length; i++) {
            int cur = nums[i];

            int j;
            for (j = i; j >= gap && cur < nums[j - gap]; j -= gap) {
                nums[j] = nums[j - gap]; // 元素后移
            }
            nums[j] = cur;
        }
    }
}
```

##### 算法分析

###### 空间复杂度

仅使用了常数个辅助存储单元，因此空间复杂度为O(1)。

###### 时间复杂度

依赖于增量序列。

平均KCN = RMN = O(n ^1.3^)，故平均时间复杂度为O(n ^1.3^)。

最坏情况下时间复杂度为O(n ^2^)。

###### 稳定性

不稳定。