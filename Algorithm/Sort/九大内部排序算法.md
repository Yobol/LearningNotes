# 内部排序算法

## 插入排序

简单直观。每次将一个待排序的的元素，按其关键字大小插入到前面已经排好序的子序列中，直到全部元素插入完成。

### 直接插入排序

**Description**

实现插入排序。

**Input**

输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。

**Output**

输出排序的数组，用空格隔开，末尾不要空格。

**Sample Input**

```
13 24 3 56 34 ‘3’ 78 12 29 49 84 51 9 100
```

**Sample Output**

```
3 ‘3’ 9 12 24 29 34 49 51 56 78 84 100
```

#### Solution 1

##### 基本思想

设初始有序序列为V(0)，每次将元素V(i)(i∈[1,n-1])依次插入到已排好序的有序子序列中。

- 遍历有序序列V(0,...,i-1)，查找出V(i)在V(0,...,i-1)中的插入位置k；
- 将V(k,...,i-1)中的所有元素向后移动一个位置；
---

在具体实现中，我们可以将以上两个步骤分为两个阶段（先找出位置k，再后移k之后且不包括k的元素），也可以在查找位置k的过程中，完成元素后移操作（如实现示例）。

---
- 将Vi复制到Vk；

将上述步骤重复执行n-1次就能得到一个有序序列。

排序过程示例：

| 初始序列                | 8    | 3    | 2    | 5    | 9    | 1    | 6    |
| ----------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 只包含元素8的初始子序列 | 8    |      |      |      |      |      |      |
| 插入元素3后的有序子序列 | 3    | 8    |      |      |      |      |      |
| 插入元素2后的有序子序列 | 2    | 3    | 8    |      |      |      |      |
| 插入元素5后的有序子序列 | 2    | 3    | 5    | 8    |      |      |      |
| 插入元素9后的有序子序列 | 2    | 3    | 5    | 8    | 9    |      |      |
| 插入元素1后的有序子序列 | 1    | 2    | 3    | 5    | 8    | 9    |      |
| 插入元素6后的有序子序列 | 1    | 2    | 3    | 5    | 6    | 8    | 9    |

包含7个元素的待排序列，只需要重复执行上述步骤6次即可得到有序序列。

##### Python3

```python
def insertion_sort(arr, size):
    for i in range(1, size):
        tmp = arr[i]

        # 从arr[i]向前开始比较，只要arr[i] < arr[j-1]就不断地将arr[j-1]后移
        j = i
        while j >= 1 and tmp < arr[j - 1]:
            arr[j] = arr[j - 1]
            j -= 1
        arr[j] = tmp
```

##### Java

```Java
/**
 * 每次都将一个待排序的元素，按其关键字大小插入到前面已经排好序的子序列中，直到全部元素插入完成
 * @param nums
 */
public void insertionSort(int[] nums) {
    int j;

    for (int i = 1; i < nums.length; i++) {
        int cur = nums[i];

        for (j = i; j >= 1 && cur < nums[j - 1]; j--) {
            nums[j] = nums[j - 1];
        }
        nums[j] = cur;
    }
}
```

##### 算法分析

###### 空间复杂度

仅使用了常数个辅助存储单元，因此空间复杂度为O(1)。

###### 时间复杂度

在排序过程中，向有序子序列中插入元素的操作进行了n-1趟，而每趟操作都分为比较关键字和移动元素，且这两种操作的次数都取决于待排序表的初始状态。

| ...         | 最好情况：有序 | 最坏情况：逆序                           | 平均   |
| ----------- | -------------- | ---------------------------------------- | ------ |
| 比较次数KCN | n - 1          | Σ(n-i), i∈[1,n-1]                        | O(n^2) |
| 移动次数RMN | 0              | Σ(n-i), i∈[2+1,2+n-1] 一次交换，三次移动 | O(n^2) |
| 复杂度      | O(n)           | 0(n^2)                                   | O(n^2) |

###### 稳定性

由于每次插入元素时总是从后往前先比较再移动（从arr[i]向前开始比较，只要arr[i] < arr[j-1]就不断地将arr[j-1]后移），所以不会出现相同元素相同位置发生变化的情况。

###### 适用性

待排序列基本有序或数量不大。




