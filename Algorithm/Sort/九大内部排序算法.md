# 内部排序算法

## 插入排序

简单直观。每次将一个待排序的的元素，按其关键字大小插入到前面已经排好序的子序列中，直到全部元素插入完成。

### 直接插入排序

**Description**

实现插入排序。

**Input**

输入的每一行代表一个数组，其中的值用空格隔开，第一个值表示数组的长度。

**Output**

输出排序的数组，用空格隔开，末尾不要空格。

**Sample Input**

```
13 24 3 56 34 ‘3’ 78 12 29 49 84 51 9 100
```

**Sample Output**

```
3 ‘3’ 9 12 24 29 34 49 51 56 78 84 100
```

#### Solution 1

##### 基本思想

设初始有序序列为V(0)，每次将元素V(i)(i∈[1,n-1])依次插入到已排好序的有序子序列中。

- 遍历有序序列V(0,...,i-1)，查找出V(i)在V(0,...,i-1)中的插入位置k；
- 将V(k,...,i-1)中的所有元素向后移动一个位置；
---

在具体实现中，我们可以将以上两个步骤分为两个阶段（先找出位置k，再后移k之后且不包括k的元素），也可以在查找位置k的过程中，完成元素后移操作（如实现示例）。

---
- 将Vi复制到Vk；

将上述步骤重复执行n-1次就能得到一个有序序列。

排序过程示例：

| 初始序列                | 8    | 3    | 2    | 5    | 9    | 1    | 6    |
| ----------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 只包含元素8的初始子序列 | 8    |      |      |      |      |      |      |
| 插入元素3后的有序子序列 | 3    | 8    |      |      |      |      |      |
| 插入元素2后的有序子序列 | 2    | 3    | 8    |      |      |      |      |
| 插入元素5后的有序子序列 | 2    | 3    | 5    | 8    |      |      |      |
| 插入元素9后的有序子序列 | 2    | 3    | 5    | 8    | 9    |      |      |
| 插入元素1后的有序子序列 | 1    | 2    | 3    | 5    | 8    | 9    |      |
| 插入元素6后的有序子序列 | 1    | 2    | 3    | 5    | 6    | 8    | 9    |

包含7个元素的待排序列，只需要重复执行上述步骤6次即可得到有序序列。

##### Python3

```python
def insertion_sort(arr, size):
    for i in range(1, size):
        tmp = arr[i]

        # 从arr[i]向前开始比较，只要arr[i] < arr[j-1]就不断地将arr[j-1]后移
        j = i
        while j >= 1 and tmp < arr[j - 1]:
            arr[j] = arr[j - 1]
            j -= 1
        arr[j] = tmp
```

##### Java

```Java
/**
 * 每次都将一个待排序的元素，按其关键字大小插入到前面已经排好序的子序列中，直到全部元素插入完成
 * @param nums
 */
public void insertionSort(int[] nums) {
    int j;

    for (int i = 1; i < nums.length; i++) {
        int cur = nums[i];

        for (j = i; j >= 1 && cur < nums[j - 1]; j--) {
            nums[j] = nums[j - 1];
        }
        nums[j] = cur;
    }
}
```

##### 算法分析

###### 空间复杂度

仅使用了常数个辅助存储单元，因此空间复杂度为O(1)。

###### 时间复杂度

在排序过程中，向有序子序列中插入元素的操作进行了n-1趟，而每趟操作都分为比较关键字和移动元素，且这两种操作的次数都取决于待排序表的初始状态。

| ...         | 最好情况：有序 | 最坏情况：逆序                           | 平均   |
| ----------- | -------------- | ---------------------------------------- | ------ |
| 比较次数KCN | n - 1          | Σ(n-i), i∈[1,n-1]                        | O(n^2) |
| 移动次数RMN | 0              | Σ(n-i), i∈[2+1,2+n-1] 一次交换，三次移动 | O(n^2) |
| 复杂度      | O(n)           | 0(n^2)                                   | O(n^2) |

###### 稳定性

由于每次插入元素时总是从后往前先比较再移动（从arr[i]向前开始比较，只要arr[i] < arr[j-1]就不断地将arr[j-1]后移），所以不会出现相同元素相同位置发生变化的情况。

###### 适用性

待排序列基本有序或数量不大。

### 折半插入排序/二分插入排序

#### Solution 1

##### 基本思想

与直接插入排序边比较边移动元素的做法不同，二分插入排序将比较和移动操作分离开来：

1. 先用二分查找法找出元素的插入位置k；
2. 再统一将待插入位置及之后的所有元素后移一个位置；
3. 将V(i)赋值给V(k)。

同样地，将上述步骤重复执行n-1次就能得到一个有序序列。

排序过程示例：

| 初始序列                    | 8     | 3    | 2    | 5    | 9    | 1    | 6    |
| --------------------------- | ----- | ---- | ---- | ---- | ---- | ---- | ---- |
| **只包含元素8的初始子序列** | **8** |      |      |      |      |      |      |
| 插入元素3后的有序子序列     | 3     | 8    |      |      |      |      |      |
| 插入元素2后的有序子序列     | 2     | 3    | 8    |      |      |      |      |
| 插入元素5后的有序子序列     | 2     | 3    | 5    | 8    |      |      |      |
| 插入元素9后的有序子序列     | 2     | 3    | 5    | 8    | 9    |      |      |
| 插入元素1后的有序子序列     | 1     | 2    | 3    | 5    | 8    | 9    |      |
| 插入元素6后的有序子序列     | 1     | 2    | 3    | 5    | 6    | 8    | 9    |

包含7个元素的待排序列，只需要重复执行上述步骤6次即可得到有序序列。

##### Python3

##### Java

```Java
/**
 * Searches a range of
 * the specified array of ints for the specified value using the
 * binary search algorithm.
 * The range must be sorted (as
 * by the {@link #sort(int[], int, int)} method)
 * prior to making this call.  If it
 * is not sorted, the results are undefined.  If the range contains
 * multiple elements with the specified value, there is no guarantee which
 * one will be found.
 *
 * @param a the array to be searched
 * @param fromIndex the index of the first element (inclusive) to be
 *          searched
 * @param toIndex the index of the last element (exclusive) to be searched
 * @param key the value to be searched for
 * @return index of the search key, if it is contained in the array
 *         within the specified range;
 *         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The
 *         <i>insertion point</i> is defined as the point at which the
 *         key would be inserted into the array: the index of the first
 *         element in the range greater than the key,
 *         or <tt>toIndex</tt> if all
 *         elements in the range are less than the specified key.  Note
 *         that this guarantees that the return value will be &gt;= 0 if
 *         and only if the key is found.
 * @throws IllegalArgumentException
 *         if {@code fromIndex > toIndex}
 * @throws ArrayIndexOutOfBoundsException
 *         if {@code fromIndex < 0 or toIndex > a.length}
 * @since 1.6
 */
public static int binarySearch(int[] a, int fromIndex, int toIndex,
                               int key) {
    rangeCheck(a.length, fromIndex, toIndex);
    return binarySearch0(a, fromIndex, toIndex, key);
}

/**
 * Checks that {@code fromIndex} and {@code toIndex} are in
 * the range and throws an exception if they aren't.
 */
private static void rangeCheck(int arrayLength, int fromIndex, int toIndex) {
    if (fromIndex > toIndex) {
        throw new IllegalArgumentException(
            "fromIndex(" + fromIndex + ") > toIndex(" + toIndex + ")");
    }
    if (fromIndex < 0) {
        throw new ArrayIndexOutOfBoundsException(fromIndex);
    }
    if (toIndex > arrayLength) {
        throw new ArrayIndexOutOfBoundsException(toIndex);
    }
}

// Like public version, but without range checks.
private static int binarySearch(int[] a, int fromIndex, int toIndex, int key) {
    int low = fromIndex;
    int high = toIndex - 1;

    while (low <= high) {
        int mid = (low + high) >>> 1;
        int midVal = a[mid];

        if (midVal < key)
            low = mid + 1;
        else if (midVal > key)
            high = mid - 1;
        else
            return mid; // key found
    }
    return -(low + 1);  // key not found.
}

/**
 *
 * 1. 先用二分查找法（调用java util.Arrays.binarySearch()方法，上面给出了源码）找出元素的插入位置k；
 * 2. 再统一将待插入位置及之后的所有元素后移一个位置；
 * 3. 将V(i)赋值给V(k)。
 */
public void binarySearchSort(int[] a) {

    for (int i = 1; i < a.length; i++) {
        int cur = a[i];
        
        int k = Arrays.binarySearch(a, 0, i, cur);
        // 如果要查找的key不存在，则返回-(k + 1) < 0，那么k = -k - 1
        if (k < 0) {
            k = -k - 1;
        }
        for (int j = i; j > k; j--) {
            a[j] = a[j - 1];
        }
        a[k] = cur;
    }
}
```

##### 算法分析

###### 空间复杂度

仅使用了常数个辅助存储单元，因此空间复杂度为O(1)。

###### 时间复杂度

比较次数与初始序列无关，而仅依赖于元素个数n，与直接插入排序相比，仅仅是减少了比较次数，约为O(nlogn)；

而移动次数没有改变，依赖于待排序列的初始状态，仍为O(n ^ 2)。

###### 稳定性

稳定。

###### 适用性

待排序列基本有序或数量不大。

### 希尔排序

又称缩小增量排序（Diminishing-Increment Sort）。

**Description**

实现Shell排序，对给定的无序数组，按照给定的间隔变化（间隔大小即同组数字index的差），打印排序结果，注意不一定是最终排序结果！

**Input**

输入第一行表示测试用例个数，后面为测试用例，每一个用例有两行，第一行为给定数组，第二行为指定间隔，每一个间隔用空格隔开。

**Output**

输出的每一行为一个用例对应的指定排序结果。

**Sample Input**

```
1
49 38 65 97 76 13 27 49 55 4
5 3
```

**Sample Output**

```
13 4 49 38 27 49 55 65 97 76
```

#### Solution 1

##### 基本思想

将待排序列在逻辑上分割成若干个形如`V(i,i+d,...,i+kd)(i∈[0,d))`的子序列，分别进行直接插入排序，不断缩小d的值，即逐渐扩大子序列的长度，直到所有子序列”合并“为一个序列时（此时，整个序列中的元素”基本有序“），再对整个序列进行一次直接插入排序。

`注：当待排序列中的元素基本有序时，效率最高的排序算法是直接插入排序。`

给定一个递减的增量序列，(d1,d2,...,dt = 1)

1. 从增量序列中取第一个增量d1（d1<n)，然后按增量d1将序列分成d1个组，所有下标模d1为`i(i∈[0,d)`的元素放在同一组中（每个组至多有`⌈n/d1⌉`个元素）,对各子序列分别进行直接插入排序；
2. 接着从增量序列中取第二个增量d2（d2<d1），重复上述过程，直到所取到的增量dt = 1，即所有元素在同一序列中；
3. 对整个序列进行一次直接插入排序（这个时候序列已经具有较好的局部有序性，故可以很快得到最终结果）；

`注：增量序列的性能与增量序列有关。Shell排序算法的作者提出的方法是d1=⌊n/2⌋,di+1=⌊di/2⌋，并且最后一个增量等于1。`

排序过程示例（增量序列为(3,1)）：

| 初始序列              | 8    | 3    | 2    | 5    | 9    | 1    | 6    |
| --------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| n=7，增量d1为⌊7/2⌋=3  | 5    | 3    | 1    | 6    | 9    | 2    | 8    |
| d1=3，增量d2为⌊3/2⌋=1 | 1    | 2    | 3    | 5    | 6    | 8    | 9    |

包含7个元素的待排序列，只需要重复执行上述步骤6次即可得到有序序列。

##### Python3

```Python
def shell_sort(nums):
    gap = len(nums) / 2
    while gap >= 1:
        for i in range(gap, len(nums), 1):
            cur = nums[i]

            j = i
            while j >= gap and cur < nums[j - gap]:
                nums[j] = nums[j - gap]
                j -= gap
            nums[j] = cur
        gap /= 2
```

##### Java

```Java
/**
 * 将待排序列在逻辑上分割成若干个形如V(i,i+d,...,i+kd)(i∈[0,d))的子序列，分别进行直接插入排序
 * 不断缩小d的值，即逐渐扩大子序列的长度，直到所有子序列”合并“为一个序列时
 * 此时，整个序列中的元素”基本有序“，再对整个序列进行一次直接插入排序。
 */
private void shellSort(int[] nums) {
    for (int gap = nums.length / 2; gap >= 1; gap /= 2) {
        for (int i = gap; i < nums.length; i++) {
            int cur = nums[i];

            int j;
            for (j = i; j >= gap && cur < nums[j - gap]; j -= gap) {
                nums[j] = nums[j - gap]; // 元素后移
            }
            nums[j] = cur;
        }
    }
}
```

##### 算法分析

###### 空间复杂度

仅使用了常数个辅助存储单元，因此空间复杂度为O(1)。

###### 时间复杂度

依赖于增量序列。

平均KCN = RMN = O(n ^1.3^)，故平均时间复杂度为O(n ^1.3^)。

最坏情况下时间复杂度为O(n ^2^)。

###### 稳定性

不稳定。

## 交换排序

不断地根据序列中两个元素关键字的比较结果来交换这两个元素在序列中的位置，直到不再有反序的对偶为止。

### 冒泡排序

每趟排序都会按照从小到大的顺序将一个元素放到其最终的位置上。

**Description**

实现冒泡排序。

**Input**

输入的每一行表示一个元素为正整数的数组，所有值用空格隔开，第一个值为数组长度，其余为数组元素值。

**Output**

输出的每一行为排序结果，用空格隔开，末尾不要空格。

**Sample Input**

```
8 3 2 5 9 1 6
```

**Sample Output**

```
1 2 3 5 6 8 9
```

#### Solution1

##### 基本思想（递增）

假设待排序表长为n，从后往前两两比较相邻元素的值，若为逆序（前面的比后面的大），则交换它们的位置，直到序列比较完（比较n-1次），称为一次“冒泡”，其结果为将待排序列中的最小元素交换到最前面。下一次“冒泡”时，前一次“冒泡”确定的最小元素不再参与比较，即待排序列减少一个元素，每次“冒泡”的结果都必将序列中的最小元素交换到序列的最终位置，...，至多做n-1次排序，就能将所有元素排好序。

排序过程示例：

| 初始序列            | 8     | 3     | 2     | 5     | 9     | 1     | 6     |
| ------------------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| **有序序列长度为1** | **8** | **3** | **2** | **5** | **9** | **1** | **6** |
| 有序序列长度为2     | 3     | 8     | 2     | 5     | 9     | 1     | 6     |
| 有序序列长度为3     | 2     | 3     | 8     | 5     | 9     | 1     | 6     |
| 有序序列长度为4     | 2     | 3     | 5     | 8     | 9     | 1     | 6     |
| 有序序列长度为5     | 2     | 3     | 5     | 8     | 9     | 1     | 6     |
| 有序序列长度为6     | 1     | 2     | 3     | 5     | 8     | 9     | 6     |
| 有序序列长度为7     | 1     | 2     | 3     | 5     | 6     | 8     | 9     |

包含7个元素的待排序列，只需要重复执行上述步骤6次即可得到有序序列。

##### Python3

```python
def bubble_sort(arr, size):
    for lenOfSorted in range(size - 1):
        isSorted = True  # 本次冒泡是否发生交换，每次开始前设置为False
        for pos in range(size - 1, lenOfSorted, -1):
            if arr[pos - 1] > arr[pos]:
                arr[pos - 1], arr[pos] = arr[pos], arr[pos - 1]
                isSorted = False
        if isSorted:  # 不一定要进行n - 1次排序
            return  # 本次冒泡过程没有发生交换，说明表已经有序

```

##### Java

```Java
/**
 * 假设待排序表长为n，从后往前两两比较相邻元素的值，
 * 若为逆序（前面的比后面的大），则交换它们的位置，
 * 直到序列比较完（比较n-1次），称为一次“冒泡”，其结果为将待排序列中的最小元素交换到最前面。
 *
 * 下一次“冒泡”时，前一次“冒泡”确定的最小元素不再参与比较，即待排序列减少一个元素，
 *
 * 每次“冒泡”的结果都必将序列中的最小元素交换到序列的最终位置。
 * 至多做n-1次排序，就能将所有元素排好序。
 */
public void bubbleSort(int[] nums) {
    boolean isSorted;
    for (int lenOfSorted = 1; lenOfSorted < nums.length; lenOfSorted++) {
        isSorted = true;
        for (int pos = nums.length - 1; pos >= lenOfSorted; pos--) {
            if (nums[pos] < nums[pos - 1]) {
                swap(nums, pos, pos - 1);
                isSorted = false;
            }
        }
        if (isSorted) { // 不一定要进行n - 1躺冒泡，且每次不一定要遍历整个序列
            return; // 本躺遍历后没有发生交换，说明序列已经有序
        }
    }
}
```

##### 算法分析

###### 空间复杂度

仅使用了常数个辅助存储单元，因此空间复杂度为O(1)。

###### 时间复杂度

| ...         | 最好情况：有序 | 最坏情况：逆序                         | 平均   |
| ----------- | -------------- | -------------------------------------- | ------ |
| 比较次数KCN | n - 1          | Σ(n-i), i∈[1,n-1]                      | O(n^2) |
| 移动次数RMN | 0              | Σ3*(n-i), i∈[1,n-1] 一次交换，三次移动 | O(n^2) |
| 复杂度      | O(n)           | 0(n^2)                                 | O(n^2) |

###### 稳定性

稳定。

### 快速排序

同冒泡排序一样，快速排序的每趟排序也都会将一个元素放到其最终的位置上，但并不是按照从小到大的顺序放置的，即快排算法并不产生有序子序列。

---

**Description**

快速排序的核心思想是使用元素的值对数组进行划分。

**Input**

输入的每一行表示一个元素为正整数的数组，所有值用空格隔开，第一个值为数组长度，其余为数组元素值。

**Output**

输出的每一行为排序结果，用空格隔开，末尾不要空格。

**Sample Input**

```
13 24 3 56 34 3 78 12 29 49 84 51 9 100
```

**Sample Output**

```
3 3 9 12 24 29 34 49 51 56 78 84 100
```

#### 基本思想

快速排序是基于分治法实现的：

在待排序列V(0,...,n-1)中任取一个元素pivot作为基准（一般取第一个元素），通过一次排序将待排序列划分为独立的两部分V(0,...,k-1)和V(k+1,...,n-1)，使得V(0,...,k-1)中所有元素均小于pivot，V(k+1,...,n-1)中所有元素均大于pivot，则pivot放在了最终位置V(k)上，这个过程称作一次**快速排序**。而后分别递归地对两个子序列重复上述过程，直到每个子序列为空或只包含一个元素，即所有元素都放在了其最终位置上。

#### Solution1:Non-recursive

##### Python3

```Python
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()

    def top(self):
        return self.items[-1]

    def size(self):
        return len(self.items)


def partition(arr, low, high):
    """
    分区操作
    :param arr:待排序数组
    :param low:待排序数组起始位置
    :param high:待排序数组终止位置
    :return:基准线下标
    """
    pivot = arr[low]
    while low < high:
        while low < high and arr[high] >= pivot:
            high -= 1
        if low < high:
        	arr[low], arr[high] = arr[high], arr[low]
            low++
        while low < high and arr[low] <= pivot:
            low += 1
        if low < high:
        	arr[low], arr[high] = arr[high], arr[low]
            high--
    return low


def quick_sort_non_recursive(arr, size):
    """
    模拟栈操作实现非递归的快速排序
    :param arr:待排序数组
    :param size:待排序数组的长度
    :return:排序后的数组
    """
    if size >= 2:
        stack = Stack()
        stack.push(size - 1)
        stack.push(0)
        while stack.size() > 0:
            low = stack.pop()
            high = stack.pop()
            pivot_index = partition(arr, low, high)
            if low < pivot_index - 1:  # 小于pivot的子序列长度大于1
                stack.push(pivot_index - 1)
                stack.push(low)
            if high > pivot_index + 1:  # 大于pivot的子序列长度大于1
                stack.push(high)
                stack.push(pivot_index + 1)

```

##### Java

```Java
private int partition(int[] nums, int low, int high) {
    int pivot = nums[low];
    while (low < high) {
        while (low < high && nums[high] >= pivot) high--;
        if (low < high) {
            swap(nums, low, high);
            low++;
        }
        while (low <high && nums[low] <= pivot) low++;
        if (low < high) {
            swap(nums, low, high);
            high--;
        }
    }
    return low;
}

public void quickSort(int[] nums) {
    if (null != nums || nums.length >= 2) {
        Stack<Integer> stack = new Stack<Integer>();
        stack.push(nums.length - 1);
        stack.push(0);
        while (!stack.isEmpty()) {
            int low = stack.pop();
            int high = stack.pop();
            int pivotPos = partition(nums, low, high);
            if (low < pivotPos - 1) { // 小于pivot的子序列长度大于1
                stack.push(pivotPos - 1);
                stack.push(low);
            }
            if (high > pivotPos + 1) { // 大于pivot的子序列长度大于1
                stack.push(high);
                stack.push(pivotPos + 1);
            }
        }
    }            
}
```

#### Solution2:Recursive

##### Python3

```Python
def quick_sort_recursive(arr, size):
    if size < 2:
        return arr
    else:
        pivot = arr[0]
        less = []
        greater = []
        for i in arr[1:]:
            if i <= pivot:
                less.append(i)  # 从待排序列中挑选出所有比pivot小的元素
            else:
                greater.append(i)  # 从待排序列中挑选出所有比pivot小的元素
        return quick_sort_recursive(less, len(less)) + [pivot] + quick_sort_recursive(greater, len(greater))
```

##### Java

```Java
public void quickSort(int[] nums) {
    quickSortHelper(nums, 0, nums.length - 1);
}

private int partition(int[] nums, int low, int high) {
    int pivot = nums[low];
    while (low < high) {
        while (low < high && nums[high] >= pivot) high--;
        if (low < high) {
            swap(nums, low, high);
            low++;
        }
        while (low <high && nums[low] <= pivot) low++;
        if (low < high) {
            swap(nums, low, high);
            high--;
        }
    }
    return low;
}

private void quickSortHelper(int[] nums, int low, int high) {
    if (low < high) {
        int pivotPos = partition(nums, low, high);
        quickSortHelper(nums, low, pivotPos - 1);
        quickSortHelper(nums, pivotPos + 1 ,high);
    }
}
```



#### 算法分析

##### 空间复杂度

非递归方式实现快速排序需要借助堆栈来保存后续进行partition（分区）需要的信息。

| ...    | 最好情况：每次选取的pivot都是待排序列的中值 | 最坏情况：每次选取的pivot都是待排序列的最值 | 平均    |
| ------ | ------------------------------------------- | ------------------------------------------- | ------- |
| 复杂度 | O(logn)                                     | O(n)                                        | O(logn) |

递归方式实现快速排序需要借助一个递归工作栈来保存递归调用的必要信息，其容量应该与递归调用的最大深度一致。

| ...    | 最好情况：每次选取的pivot都是待排序列的中值 | 最坏情况：每次选取的pivot都是待排序列的最值 | 平均    |
| ------ | ------------------------------------------- | ------------------------------------------- | ------- |
| 复杂度 | O(logn)                                     | O(n)，要进行n-1次递归调用                   | O(logn) |

##### 时间复杂度

**最坏情况**：每次选取的pivot都是待排序列的最值
$$
O(n^2)
$$
**最好情况**：每次选取的pivot都是待排序列的中值
$$
O(nlogn)
$$
**平均情况**：
$$
O(nlogn)
$$
快排是所有内部排序算法中平均性能最好的。

##### 稳定性

不稳定