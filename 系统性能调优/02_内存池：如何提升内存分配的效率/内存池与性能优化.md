# 内存池与性能优化

> 如何提升内存分配的效率？
>
> 极客时间 - 陶辉 - 内存池：如何提升内存分配的效率？
>
> https://time.geekbang.org/column/article/230221

为什么需要了解内存池的底层原理？

> 在 Linux 系统中，用 Xmx 设置 JVM 的最大堆为 8GB，但在近百个并发进程工作的情况下，观察到 Java 进程占用了 14GB 的内存，为什么会这样呢？
>
> 绝大多数高级语言都是用 C 语言编写的，申请内存必须经过 C 库，而 C 库通过预分配更大的空间作为内存池，以加快后续申请内存的速度。这样，预分配的 6GB 的 C 库内存池就与JVM预分配的 8GB 内存池叠加在一起，造成了 Java 进程的内存占用超过了预期。

掌握内存池的特性，既可以避免写程序时内存占用过大，导致服务器性能下降或者进程 OOM（Out Of Memory，内存溢出）被系统杀死；还可以加快内存分配的速度。

> 在系统空闲时申请内存花费不了多少时间，但是对于分布式环境下繁忙的多线程服务，获取内存的时间会上升几十倍。

内存池是非常底层的技术，深入理解它的特性可以根据应用场景来选择合适的内存池。在多种编程语言共存的分布式系统中，内存池有广泛的应用，优化内存池带来的任何微小的性能提升，都将被分布式集群巨大的主机规模放大，从而带来整体上非常可观的收益。

## 隐藏的内存池

> 业务代码 -> 应用层内存池 -> C 库内存池 -> 操作系统内核

通常在业务代码和操作系统内核之间，存在着两层内存池。当代码申请内存时，首先会应用层内存池申请内存，如果应用层内存池有足够的可用内存，就直接返回给业务代码，否则，就会向更底层的 C 库内存池申请内存，当 C 库内存池内存不够时，才会向操作系统内核申请内存。

> 为什么 Java 除了使用 JVM 预分配的应用内存池，还会使用到C库内存池？
>
> 因为除了 JVM 负责管理的堆内存外，Java 还有一些堆外内存，由于它不使用 JVM 的垃圾回收机制，所以更稳定、持久、I/O 速度更快，这些堆外内存由 C 库内存池负责分配。

几乎所有的程序都会使用 C 库内存池分配的内存，C 库内存池影响着系统下依赖它的所有进程。

## C 库内存池对系统性能有什么影响

> Ptmalloc2 是 Linux 默认的 C 库内存池。

C 库内存池工作时，会预分配比申请的内存更大的空间作为内存池。比如，当主进程申请 1B 的内存时，Ptmalloc2 会预分配 132KB 的内存空间（Ptmalloc2 中叫 Main Arena），应用代码再申请内存时，会从预分配的内存中继续分配。

当内存池中的内存被应用代码主动释放时，Ptmalloc2 并不会将其释放给操作系统，而仍然放在内存池中，作为用户态内存供后续的内存申请动作复用。

Ptmalloc2 会为每个子系统预分配内存（Thread Arena），32 位系统下为 1MB，64 位系统下为 64MB。

> 在 64 位系统上，如果有 100 个线程，将至少有 100 * 64MB = 6.25GB 的内存将会被内存池占用。
>
> 并且子线程内存池的数量最多只能是 CPU 核数的 8 倍，如 32 核的服务器上最多只会有 8 * 32 = 256 个子线程内存池，将至少有 256 * 64 = 16GB 的内存将一直被内存池占用。

Linux 下的 JVM 编译时默认使用了 Ptmalloc2 内存池，因此每个线程都预分配了 64MB 的内存，这造成含有上百个 Java 线程的 JVM 多使用了 6.25GB 的内存。在多数情况下，这些预分配出来的内存池可以加快后续内存分配的性能。然而，Java 中的 JVM 内存池已经管理了绝大部分内存，不太能接收莫名多出来的 6GB 的内存。

有两种解决办法：

1. 调整 Ptmalloc2 的工作方式。通过设置 `MALLOC_ARENA_MAX` 环境变量，可以限制线程内存池的最大数量（当线程内存池的数量减少后，会影响 Ptmalloc2 分配内存的速度）；
2. 使用预分配内存空间更少的内存池。如 Google 的 TCMalloc。

> C 库内存池可以提升内存分配的速度，但是会额外占用大量的内存空间。
>
> 可以限制 C 库内存池的数量，也可以限制单个 C 库内存池预分配的空间。

## 如何根据应用场景选择内存池

> TCMalloc 适用于多线程小内存的应用场景。
>
> Ptmalloc2 适用于大内存的应用场景。

Ptmalloc2 允许线程间共用内存池以提升性能。因此每次分配内存 Ptmalloc2 一定要加锁，才能解决共享资源间的互斥问题。加锁会在一定程度上影响申请内存的速度，即间接影响到程序的处理性能，并且竞态线程数量越多，系统维持内存资源一致性付出的代价就越大，性能损耗也就越严重。

TCMalloc 针对小内存（TCMalloc 规定小于等于 256KB 的称为小内存，大于 256KB 且小于等于 1MB 的称为中内存，大于 1MB 的称为大内存）做了很多优化，每个线程独立分配内存，无须加锁，所以速度更快。但是 TCMalloc 对中内存和大内存的分配内存很慢。

>  如果主要分配 256KB 以下的内存，特别是在多线程环境下，应当选择 TCMalloc；否则应使用通用性更好的 Ptmalloc2。

## 从堆还是栈上分配内存

对于 C/C++/Java/Golang 等静态类型语言，不使用 `new` 或 `malloc` 关键字分配的对象大都在栈中，否则在堆中，对于 Golang 会将那些用 `new` 关键字创建的对象，在不影响功能语义的前提下，自动改为在栈中分配。

对于 Python/JavaScript 等动态类型语言，所有的内存都是从堆中分配的。

> 为什么从栈上分配内存要比堆快？

1. 栈上分配的内存在编译期间就确定了；
2. 每个线程都有独立的栈，所以在分配内存时不需要加锁保护；

> 在栈上分配内存有什么缺点？

1. 栈上分配的内存声明周期有限，会随着函数调用结束自动释放；
2. 栈内存有限，很容易出现 `StackOverFlow` 错误。

## 总结

1. 进程申请内存的速度，以及总内存空间都受到内存池的影响；
2. 当进程的占用空间超出预期时，应该意识到时 C 库内存池的存在，使用的是什么内存池，为每个线程预分配的空间是多少；
3. 不同的 C 库内存池有不同的适用场景：
   1. Google 的 TCMalloc 适用于多线程场景下小内存（小于等于256 KB）的分配和释放；
   2. Linux 默认的 Ptmalloc2 堆各类尺寸的内存分配和释放都有稳定的表现，通用性更强；
4. 内存池管理的是堆内存，不能管理栈内存；
5. 栈上分配内存更快，但栈内存生命周期/使用容量受限，在满足栈使用场景的情况下优先使用栈。

## 思考

> 分配对象时，除了分配内存，还需要初始化对象的数据结构。内存池对于初始化对象有什么帮助吗？

1. 内存池可以利用“享元模式”将常用的对象一直保存，减少重复申请导致的性能损耗。

