# 使用最小花费爬楼梯

## 题目描述

数组的每个索引做为一个阶梯，第`i`个阶梯对应着一个非负数的体力花费值`cost[i]`(索引从0开始)。

每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。

您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为`0`或`1`的元素作为初始阶梯。

**示例 1：**

```
输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
```

**示例 2：**

```
输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
```

**注意：**

1. `cost`的长度将会在`[2, 1000]`。
2. 每一个`cost[i]`将会是一个`Integer`类型，范围为`[0, 999]`。

## 解题思路

### 个人AC

```Java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        
        if (n == 2) return Math.min(cost[0], cost[1]);
        
        int[] dp = new int[n + 1];
        // 因为可以选择从第1阶或第2阶开始爬，所以爬到第1阶或第2阶需要的最小体力皆为0
        // 爬到第i + 1阶，可以选择从第i - 1阶爬2阶上来，或者选择从第i阶爬1阶上来
        for (int i = 2; i <= n; i++) { // 计算爬到第i + 1阶需要的最小体力
            dp[i] = Math.min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1]);
        }
        return dp[n]; // 返回爬到楼层顶部的最小体力
    }
}
```

时间复杂度： $O(n)$；

空间复杂度： $O(n)$。

### 最优解

同上。