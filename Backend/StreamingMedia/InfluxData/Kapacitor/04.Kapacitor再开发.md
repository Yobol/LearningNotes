# Kapacitor 再开发

## 自定义算子

1. 定义 Node 结构体：

   > kapacitor/pipeline/custom.go（需要手动创建）

   ```go
   type CustomNode struct {
       chainnode
       
       // 算子需要的数据，注意将暴露给外部的变量以大写字母开头
       Data1 string
       Data2 int
       ...
       
   }
   ```

2. 构建一个创建 Node 实例的方法：

   > kapacitor/pipeline/custom.go

   ```go
   func newCustomNode(wants EdgeType, data1 string) *CustomNode {
       return &Custom {
           chainnode: newBasicChainNode("Custom", wants, NoEdge),
           Data1:   data1
       }
   }
   ```

3. 提供一个方法，可以将自定义的算子添加到pipeline中：

   > kapacitor/pipeline/node.go（已有）

   ```go
   func (c *chainnode) Custom(data1) *CustomNode {
       h := new CustomNode(c.Provides())
       c.linkChild(h)
       return h
   } 
   ```

4. 实现处理逻辑：

   > kapacitor/custom.go（pipeline包下的所有节点在根目录kapacitor下皆有同名文件）

   ```go
   package kapacitor
   
   import (
   	"github.com/influxdata/kapacitor/pipeline"
   )
   
   type CustomNode struct {
       // 使用组合来实现 kapacitor 包下的 node 类型
       // Include the generic node implementation
       node
       
       // Keep a reference to the pipeline node
       h *pipeline.CustomNode
   }
```
   
   构建一个函数来创建上面所定义类型的实例：
   
   ```go
   func newCustomNode(et *ExecutingTask, n *pipeline.CustomNode, d NodeDiagnostic) (*CustomNode, error) {
       h := &CustomNode {
           // pass in necessary fields to the 'node' struct
           node: node {
               Node: n,
               et:	  et,
               diag: d,
           }
           // Keep a reference to the pipeline.CustomNode
           h:	  n,
       }
       // Set the function to be called when running the node more on this in a bit.
       // Action可以换为符合算子特性的单词，如消息队列算子可以为runPub，傅里叶转换算子可以为runTransform
       h.node.runF = h.runAction
       return h
   }
   ```
   
   > kapacitor/task.go
   
   关联kapacitor根目录和pipeline目录下的自定义Node：
   
   ```go
   // Create a node from a given pipeline node
   func (et *ExecutingTask) createNode(p pipeline.Node, d NodeDiagnostic) (n Node, err error) {
       switch t := p.(type) {
           ...
           case *pipeline.CustomNode:
           	n, err = newCustomNode(et, t, d)
           ...
       }
   }
   ```
   
   > kapacitor/custom.go
   
   ```go
   func (fft *CustomNode) runAction(data []byte) error {
       return nil
   }
   ```
   
5. 使用`edge.Edge`类型来完成算子之间的通信：

